# SQL

## 范式

- 码：一个表中，可以唯一决定一个元组的属性集合
- 主键：可以唯一决定元组的某个属性。如：成绩表（学号，课程号）合起来叫做码，分开看：学号是主键，课程号也是主键
- 非主属性：不属于码的属性
- 主属性：属于码的属性
- 候选键：每一个都不一样、非空的属性，有潜在的主键意义。如：课程序列号
- 超键superkey：能唯一标示多元组（即“行”）的属性集
- 外键foreign key：父数据表(Parant Entity)的主键(primary key)会放在另一个表，当作属性创建彼此的关系

范式描述了属性之间的关系。范式约束了一个表的属性。这种约束的主要作用，可以理解为消除数据冗余，降低数据管理成本，如更新一个属性，只需要更新一个地方，而不是多个地方都要更新。在编程中，为了复用代码，如：前端组件的概念，编程中函数的概念。就要求了，组件或者函数，这些代码块被拆分到恰到好处，以至于这些代码块虽然互相依赖，但没有重复代码。而这种恰到好处的要求，往往是这些代码块功能正交。

属性是基本概念，保证其自身与自身正交，不能包含关系。即1NF。

既然是表，则需要有属性能完全代表或者描述此表，概无遗漏，这样表的存在，才能被操作，类似于编程中指针的概念。保证了码和非主属性的正交，即不会再有非主属性可以成为主属性。即2NF。

保证了表的主属性和非属性的关系，并不能保证表自身是否只存在一种关系，表自身应该包含的关系应该正交的。
如果还包含其他关系，则应该被拆出去。即3NF。

一般到3NF就够了。即表自身的依赖关系单纯了，其中属性之间依赖关系也单纯了，这样就保证了表与表之间必然
正交，无冗余数据。

但如果一个表，可以有多个主属性描述或代表，进一步约束表，约束主属性，一个表只能有一个主属性。即4NF。

从工程角度出发，当我们构造一个表的时候，应该思考这个表与其他表应该是正交的（3NF），是能被主属性完全
代表的（2NF）的，包含的属性是原子的（1NF）。更高的要求，主属性是唯一的，便于代表这个表单。


|                                                  | UNF    | 1NF    | 2NF    | 3NF    | EKNF   | BCNF   | 4NF    |
| --------------------------------------------:    | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 主键（无重复元组）                               | ✔      | ✔      | ✔      | ✔      | ✔      | ✔      | ✔      |
| 没有重复组                                       | ✔      | ✔      | ✔      | ✔      | ✔      | ✔      | ✔      |
| 字段原子性（元组只有一个值）                     | ✗      | ✔      | ✔      | ✔      | ✔      | ✔      | ✔      |
| 没有部分函数依赖（值依赖所有主键组成的码）       | ✗      | ✗      | ✔      | ✔      | ✔      | ✔      | ✔      |
| 没有传递函数依赖（值仅依赖候选键）               | ✗      | ✗      | ✗      | ✔      | ✔      | ✔      | ✔      |
| 每一个非平凡的函数依赖涉及一个超键或者主键的子键 | ✗      | ✗      | ✗      | ✗      | ✔      | ✔      | ✔      |
| 没有函数依赖造成的冗余                           | ✗      | ✗      | ✗      | ✗      | ✗      | ✔      | ✔      |
| 每一个非平凡的多值依赖都有一个超键               | ✗      | ✗      | ✗      | ✗      | ✗      | ✗      | ✔      |


### 1NF第一个范式

属性不可分割。不可分割，视设计目标而定。中国姓名是一个字段，国外可能要区分。

个人理解：保持属性的原子性。

可以理解为：属性本身的不能含有依赖关系。

限定了属性的单纯性，不含依赖关系。

例子：地址属性，可以拆分为省市区，就不能作为一个属性。

解决办法：拆分属性，将地址改成多个属性。

#### 反例？

部分情况下，需要存一个大JSON。

### 2NF第二范式

非主属性完全依赖码。不能存在仅仅依赖一部分属性。

特殊情况：码只有一个属性，必满足第二范式。

个人理解：码能完全描述属性。即多个属性的集合能代表其他属性。但不对其他属性之间的关系有要求。对非主属性的要求，在3NF中。

可以理解为：限定了主属性与所有非主属性都存在依赖关系。如果有部分非主属性，只与部分主属性有依赖关系，则不符合2NF。

码作为一个整体，与非主属性是一一对应的依赖；要求了码既不能多，也不能少。码代表的集合，能够用码描述，不多也不少。如果集合有不用码代表的属性，或者可以只用码的一部分主属性
代表的属性，则不符合。

例子：学生表（学号，姓名，年龄，地址，课程号，学分），主键应该是学号加课程号。因为学号不能确定学分这个属性，需要合并两者构成主键。不符合2NF，因为存在部分依赖。或者（学号，学生名，课程号），学生名是部分依赖，即：学号->学生名。

所以，判断是否满足2NF，需要先找出主键，如果是一个字段构成主键，则满足2NF，但不一定满足3NF。

解决办法：将部分单独拿出来，用一个外键替代。

### 3NF第三范式

消除非主属性之间的依赖关系，只保留非主属性于码的依赖关系。

个人理解：消除冗余。信息只能在一个地方存储，不能出现在多张表中。如果非主属性之间有依赖，那么存在把这非主属性独立成表的可能，其他表可能与这些属性有依赖。如果不独立为表，则其他地方就需要再次存储这些属性，造成数据冗余。

可以理解为：限定了非主属性的依赖关系。

例子：学号，课程号，系别，系主任。系别和系主任是非主属性，学号和课程号是主属性。但非主属性系别和系主任之间有依赖关系：系别->系主任。就造成了依赖：学号->系别->系主任。不符合3NF。

解决办法：将非主属性于依赖码，单独成表。原表中用外键表示。


#### 数据量很大的情况？

### 4NF第四范式(BCNF)

每一个表单只有一个候选键。

例子：（学号，名字，学生QQ），我们可以设置学号为主键，但学生QQ和学号，都是候选键，不符合BCNF。

解决方法：保留一个候选键，拆分其他候选键，单独成表。

所有属性（含非键属性与键属性）不能依赖非键属性。

## join

JOIN将两个或多个表组合，生成的集合，可以保存为表，或者当作表来使用。

ANSI标准SQL一共五种：内连接 INNER，全外连接 FULL OUTER，左连接 LEFT OUTER，右连接 RIGHT OUTER，交叉连接 CROSS。

### cross join 交叉连接(笛卡尔连接 cartesian join 或叉乘 Product)

笛卡尔积是所有内连接的基础。

显示：

``` sql

SELECT * FROM table1 CROSS JOIN table2;

```

隐式：

``` sql

SELECT * FROM table1, table2;

```

### inner join

内连接基于连接谓词，将两张表的列组合在一起，产生新的结果表。

连接产生的结果，可以定位为首先对两张表做笛卡尔积，把表A和表B中每一行进行组合，返回满足谓词的记录。实际实现可能不是这样，笛卡尔积运算效率低。

显式：

``` sql

SELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.id

```

隐式：

``` sql

SELECT * FROM table1, table2 WHERE table1.id = table2.id

```

### outer

外连接不要求两个表单每一行记录在对方表中都有一条匹配的记录。要保留所有记录的表称为保留表。因此，外连
接可以分为：左外连接，右外连接和全连接。

#### right outer join and left outer join

right join从右表(table2)返回所有的行，即使左表(table1)中没有匹配。如果左表没有匹配，则为NULL。left join则相反。

``` sql

SELECT column_name FROM table1 RIGHT OUTER JOIN table2 ON table.column_name=table2.column_name;

```

#### 内存不够怎么办？


#### 数据太大怎么办？冗余数据？

### 实现算法

#### 嵌套循环(loop join)

类似C语言的双重循环。适用于外层循环的表数据少，内层循环表创建了索引的情况。

#### 合并连接(merge join)

类似有序数组的合并。如果预先建立好索引，合并连接的复杂度是线性的。

#### 哈希连接(hash join)

哈希连接选择行数较小的表生成输入，对连接的列应用哈希函数，把其行放入哈希桶中。



## 参考资料

- [Say NO to Venn Diagrams When Explaining JOINs](https://blog.jooq.org/2016/07/05/say-no-to-venn-diagrams-when-explaining-joins/)

- [SQL JOIN](https://zh.wikipedia.org/wiki/%E8%BF%9E%E6%8E%A5)

- [分布式数据库下子查询和join等复杂sql如何实现？](https://www.zhihu.com/question/38038257)

## change log

- 2019/5/10 created doc
- 2019/9/6 补充join文档
